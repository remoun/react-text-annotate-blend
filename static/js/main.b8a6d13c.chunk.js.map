{"version":3,"sources":["components/utils/utils.ts","components/utils/blend.ts","components/Mark.tsx","components/SplitTag.tsx","components/TextAnnotateBlend.tsx","Demo.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["range","start","end","length","Array","from","_","i","colParser","col","charAt","r","g","b","a","hexToRGB","toLowerCase","substr","sep","indexOf","rgb","split","rgbParse","blend","colA","colB","opacity","meanCol","map","Math","sqrt","rgbMean","selectionIsEmpty","selection","anchorNode","compareDocumentPosition","focusNode","focusOffset","anchorOffset","tagTransformer","value","onChange","forEach","tag","tags","newTag","pop","newTagRange","overlap","val","filter","Boolean","isNumber","isRange","focusOverlap","baseTag","splits","valA","valB","color","splitGap","tagRange","finLen","breaks","j","breakPoint","slice","group","set","tagFilter","outRanges","flatMap","tagVal","tagMeta","metaData","every","includes","splitOneGap","min","max","isFinite","blender","currentTags","sortBy","localTags","splitLen","result","counter","compTag","shift","push","getOverlap","metaIndex","blendRange","tagIndices","totalIncInds","tagRanges","semiInclusive","totalInclusive","blendInclusive","index","inclusive","findIndex","incRange","incMeta","Set","meta","parentTag","splitIndex","splice","outRange","updateIndices","outTags","remainder","blendIndices","Mark","props","lumin","luminTest","style","backgroundColor","padding","data-start","data-end","onMouseUp","onClick","content","fontSize","fontWeight","marginLeft","SplitTag","mark","TextAnnotateBlend","handleSplitClick","window","getSelection","frontOverlapIndex","rearOverlapIndex","s","text","offsets","lastEnd","o","offset","splitWithOffsets","span","startBase","parentElement","getAttribute","endBase","parseInt","String","position","backward","Node","DOCUMENT_POSITION_PRECEDING","selectionIsBackwards","getSpan","empty","useStyles","makeStyles","theme","root","flexGrow","menuButton","marginRight","spacing","title","main","paddingLeft","paddingRight","pre","overflowX","init","Demo","classes","useState","setValue","setTag","COLORS","tagA","tagB","tagC","Paper","className","Box","p","pl","mb","elevation","maxWidth","FormControl","variant","Select","id","e","target","MenuItem","pt","JSON","stringify","pb","language","docco","App","Fragment","CssBaseline","AppBar","Toolbar","IconButton","edge","aria-label","Typography","Button","href","Container","height","m","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","createMuiTheme","MuiButtonBase","disableRipple","ReactDOM","render","StrictMode","ThemeProvider","document","getElementById"],"mappings":"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","file":"static/js/main.b8a6d13c.chunk.js","sourcesContent":["import sortBy from \"lodash.sortby\";\n\nexport const range = (start: number, end: number, length = end - start + 1) =>\n  Array.from({ length }, (_, i) => start + i);\n\nexport const hexToRGB = (col: string) => {\n  let r = \"0\",\n    g = \"0\",\n    b = \"0\";\n\n  if (col.length === 4) {\n    r = \"0x\" + col[1] + col[1];\n    g = \"0x\" + col[2] + col[2];\n    b = \"0x\" + col[3] + col[3];\n  } else if (col.length === 7) {\n    r = \"0x\" + col[1] + col[2];\n    g = \"0x\" + col[3] + col[4];\n    b = \"0x\" + col[5] + col[6];\n  }\n\n  return { r: +r, g: +g, b: +b, a: 0.75 };\n};\n\nexport const rgbParse = (col: string) => {\n  let sep = col.indexOf(\",\") > -1 ? \",\" : \" \";\n  let rgb = col.substr(4).split(\")\")[0].split(sep);\n\n  return { r: +rgb[0], g: +rgb[1], b: +rgb[2], a: 0.75 };\n};\n\ninterface blendObj {\n  [index: string]: number;\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\nconst rgbMean = (a: blendObj, b: blendObj) => {\n  const cols: string[] = [\"r\", \"g\", \"b\"];\n  const meanCol = cols.map((col) => Math.sqrt((a[col] ** 2 + b[col] ** 2) / 2));\n  let opacity: number;\n\n  if (a.r === meanCol[0] && a.g === meanCol[1] && a.b === meanCol[2]) {\n    opacity = (a.a + b.a) / 2;\n  } else {\n    opacity = 1;\n  }\n  return { r: meanCol[0], g: meanCol[1], b: meanCol[2], a: opacity };\n};\n\nconst colParser = (col: string) => {\n  if (col.charAt(0) === \"#\") {\n    return hexToRGB(col);\n  } else if (col.toLowerCase().substr(0, 3) === \"rgb\") {\n    return rgbParse(col);\n  } else {\n    return;\n  }\n};\n\nexport const luminTest = (col: string) => {\n  const { r, g, b } = colParser(col)!;\n\n  const luma = (r * 0.299 + g * 0.587 + b * 0.114) / 255;\n\n  if (luma > 0.5) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nexport const blend = (colA: string, colB: string) => {\n  let a: blendObj;\n  let b: blendObj;\n\n  a = colParser(colA)!;\n  b = colParser(colB)!;\n\n  let blend = rgbMean(a, b);\n  return (\n    \"rgb(\" + +blend.r + \",\" + +blend.g + \",\" + +blend.b + \",\" + +blend.a + \")\"\n  );\n};\n\n// interface Label {\n//   start: number;\n//   end: number;\n//   color?: string;\n//   mark?: boolean;\n// }\n\n// export const getOverlap = (content: string, splits: Array<Label>) => {\n//   return splits.map((valA, index) => {\n//     if (valA.mark === true && valA.color) {\n//       let valB = splits[index + 1];\n\n//       if (valA.end > valB.start && valB.mark && valB.color) {\n//         return {\n//           start: valB.start,\n//           end: valA.end,\n//           text: content.slice(valB.start, valA.end),\n//           mark: true,\n//           color: \"blend(valA.color, valB.color)\",\n//           overlap: true,\n//         };\n//       }\n//     }\n//   });\n// };\n\nexport const splitWithOffsets = (\n  text: string,\n  offsets: { start: number; end: number }[]\n) => {\n  let lastEnd = 0;\n  const splits = [];\n  for (let offset of sortBy(offsets, (o) => o.start)) {\n    const { start, end } = offset;\n    if (lastEnd < start) {\n      splits.push({\n        start: lastEnd,\n        end: start,\n        content: text.slice(lastEnd, start),\n      });\n    }\n    splits.push({\n      ...offset,\n      mark: true,\n      content: text.slice(start, end),\n    });\n    lastEnd = end;\n  }\n  if (lastEnd < text.length) {\n    splits.push({\n      start: lastEnd,\n      end: text.length,\n      content: text.slice(lastEnd, text.length),\n    });\n  }\n  return splits;\n};\n\nexport const selectionIsEmpty = (selection: Selection) => {\n  let position = selection.anchorNode!.compareDocumentPosition(\n    selection.focusNode!\n  );\n\n  return position === 0 && selection.focusOffset === selection.anchorOffset;\n};\n\nexport const selectionIsBackwards = (selection: Selection) => {\n  if (selectionIsEmpty(selection)) return false;\n\n  let position = selection.anchorNode!.compareDocumentPosition(\n    selection.focusNode!\n  );\n  let backward = false;\n  if (\n    (!position && selection.anchorOffset > selection.focusOffset) ||\n    position === Node.DOCUMENT_POSITION_PRECEDING\n  )\n    backward = true;\n\n  return backward;\n};\n\nexport const tagTransformer = (value: any, onChange: (value: []) => any) => {\n  //TODO remove internally\n  value.forEach((tag: any) => delete tag[\"index\"]);\n\n  if (value.length) {\n    const tags = [...value];\n    const newTag = tags.pop();\n    const newTagRange = range(newTag.start, newTag.end);\n\n    let overlap = 0;\n\n    tags.forEach((val) => {\n      \n      delete val[\"index\"]\n      \n      const tagRange = range(val.start, val.end);\n\n      let tagOverlap = tagRange\n        .map((i: number) => {\n          return newTagRange.indexOf(i) >= 0;\n        })\n        .filter(Boolean).length;\n\n      if (tagOverlap >= 2) {\n        overlap += 1;\n      }\n    });\n\n\n\n    if (overlap < 2) {\n      onChange(value);\n    }\n  } else {\n    onChange(value);\n  }\n};\n","import sortBy from \"lodash.sortby\";\nimport { blend, range } from \"./utils\";\n\nconst isNumber = (val: number | undefined): val is number => {\n  return !!val;\n};\n\nconst isRange = (val: any): val is number[] => {\n  return !!val;\n};\n\ninterface Split {\n  start: number;\n  end: number;\n}\n\ninterface Tag extends Split {\n  text?: string;\n  tag?: string;\n  color?: string;\n  index?: number;\n}\n\ninterface Blend extends Split {\n  text?: string;\n  tag: string;\n  color: string;\n}\n\ninterface Meta {\n  color?: string;\n  index?: number;\n}\n\ninterface NonBlend {\n  outRanges: number[][];\n  metaData: Meta[];\n}\n\nexport const focusOverlap = (baseTag: Tag, splits: Array<Tag>) => {\n  const valA = baseTag;\n  const overlap = splits\n    .map((valB) => {\n      if (valA.color) {\n        if (\n          valA.end >= valB.start &&\n          valA.end <= valB.end &&\n          valA.end - valB.start > 0 &&\n          valB.color\n        ) {\n          return {\n            start: valB.start,\n            end: valA.end,\n            color: blend(valA.color, valB.color),\n          };\n        } else if (\n          valA.end >= valB.start &&\n          valA.end >= valB.end &&\n          valB.end - valB.start > 0 &&\n          valB.color\n        ) {\n          return {\n            start: valB.start,\n            end: valB.end,\n            color: blend(valA.color, valB.color),\n          };\n        } else {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    })\n    .filter((val): val is Blend => !!val);\n\n  return overlap;\n};\n\nexport const getOverlap = (splits: Array<Tag>) => {\n  const localTags = [...splits];\n  const splitLen = splits.length - 1;\n\n  let result: Blend[] = [];\n  let counter = 0;\n\n  while (counter < splitLen) {\n    const compTag = localTags.shift();\n\n    compTag && result.push(...focusOverlap(compTag, localTags));\n    counter++;\n  }\n\n  return result;\n};\n\nconst splitOneGap = (tagRange: Array<number>) => {\n  const breaks: Array<number> = tagRange\n    .map((i: number, j: number) => {\n      if (i === -1) {\n        return j;\n      } else if (j === tagRange.length - 1) {\n        return j;\n      } else {\n        return undefined;\n      }\n    })\n    .filter(isNumber);\n\n  let breakPoint = 0;\n\n  return breaks\n    .map((i: number, j: number) => {\n      let group: Array<number>;\n\n      if (j === breaks.length - 1) {\n        group = tagRange.slice(breakPoint);\n      } else {\n        group = tagRange.slice(breakPoint, i);\n        breakPoint = i + 1;\n      }\n\n      if (group.length > 1) {\n        return group;\n      } else {\n        return undefined;\n      }\n    })\n    .filter(isRange);\n};\n\nconst splitGap = (tagRange: Array<number>) => {\n  const finLen = tagRange.length - 1;\n\n  const breaks: Array<number> = tagRange\n    .map((i: number, j: number) => {\n      if (i + 1 !== tagRange[j + 1] && j !== finLen) {\n        return j + 1;\n      } else if (j === finLen) {\n        return j;\n      } else {\n        return undefined;\n      }\n    })\n    .filter(isNumber);\n\n  let breakPoint = 0;\n  const outSet = breaks.map((i: number, j: number) => {\n    if (j === breaks.length - 1) {\n      return tagRange.slice(breakPoint);\n    } else {\n      const group = tagRange.slice(breakPoint, i);\n      breakPoint = i;\n      return group;\n    }\n  });\n  return outSet.filter((set) => set.length > 1);\n};\n\nconst updateIndices = (splits: Array<Tag>, blend: Array<Tag>) => {\n  const metaData: Array<Meta> = [];\n  const metaIndex: number[] = [];\n\n  const blendRange = blend.flatMap((i) => range(i.start, i.end));\n\n  let tagIndices: Array<number> = [];\n  let totalIncInds: Array<number> = [];\n\n  const tagRanges = splits\n    .map((i, j) => {\n      const tagRange = range(i.start, i.end);\n\n      const semiInclusive: boolean =\n        blendRange.includes(i.start) || blendRange.includes(i.end);\n\n      const totalInclusive: boolean = tagRange.every((val: number) =>\n        blendRange.includes(val)\n      );\n\n      const blendInclusive: boolean = blendRange.every((val: number) =>\n        tagRange.includes(val)\n      );\n      if (semiInclusive || totalInclusive || blendInclusive) {\n        tagIndices.push(j);\n      }\n      i.index = j;\n\n      if (\n        (semiInclusive && !totalInclusive) ||\n        (blendInclusive && !totalInclusive)\n      ) {\n        metaIndex.push(i.index);\n        metaData.push({\n          color: i.color,\n        });\n        return tagRange;\n      } else if (semiInclusive && totalInclusive) {\n        const inclusive = i;\n        totalIncInds.push(\n          splits.findIndex(\n            (tag, index) =>\n              tag.start <= inclusive.start &&\n              tag.end >= inclusive.end\n          )\n        );\n        return undefined;\n      } else {\n        return undefined;\n      }\n    })\n    .filter(isRange);\n\n  const incRange: number[][] = [];\n  const incMeta: Array<Meta> = [];\n  totalIncInds = [...new Set(totalIncInds)];\n\n  for (let val of totalIncInds) {\n    if (metaIndex.every((meta) => meta !== val) && val >= 0) {\n      let parentTag = range(splits[val].start, splits[val].end);\n\n      blend.forEach((overlap) => {\n        let start: number = 0;\n        let end: number = 0;\n\n        if (\n          overlap.end - overlap.start === 1 &&\n          parentTag.includes(overlap.end) &&\n          parentTag.includes(overlap.start)\n        ) {\n          const splitIndex = parentTag.indexOf(overlap.start) + 1;\n          parentTag.splice(splitIndex, 0, -1);\n          return;\n        }\n\n        if (parentTag.includes(overlap.start)) {\n          const index = parentTag.indexOf(overlap.start);\n          if (index === 0) {\n            start = overlap.start;\n          } else {\n            start = overlap.start + 1;\n          }\n        }\n\n        if (parentTag.includes(overlap.end)) {\n          const index = parentTag.indexOf(overlap.end);\n          if (index === parentTag.length - 1) {\n            end = overlap.end;\n          } else {\n            end = overlap.end - 1;\n          }\n        }\n\n        [...parentTag] = parentTag.filter(\n          (i) => !range(start, end).includes(i)\n        );\n      });\n      incRange.push(parentTag);\n      incMeta.push({\n        color: splits[val].color,\n      });\n    }\n  }\n\n  const outRanges = tagRanges.map((val) => {\n    let outRange = val;\n\n    blend.forEach((overlap, _) => {\n      let start: number, end: number;\n\n      if (\n        overlap.end - overlap.start === 1 &&\n        outRange.includes(overlap.start)\n      ) {\n        const splitIndex = outRange.indexOf(overlap.start) + 1;\n        outRange.splice(splitIndex, 0, -1);\n        return;\n      }\n\n      if (outRange.includes(overlap.start)) {\n        const index = outRange.indexOf(overlap.start);\n        if (index === 0) {\n          start = overlap.start;\n        } else {\n          start = overlap.start + 1;\n        }\n      }\n\n      if (outRange.includes(overlap.end)) {\n        const index = outRange.indexOf(overlap.end);\n        if (index === outRange.length - 1) {\n          end = overlap.end;\n        } else {\n          end = overlap.end - 1;\n        }\n      }\n\n      outRange = outRange.filter((i) => !range(start, end).includes(i));\n    });\n\n    return outRange;\n  });\n  return {\n    outRanges: [...outRanges, ...incRange],\n    metaData: [...metaData, ...incMeta],\n    tagIndices: [...tagIndices, ...totalIncInds],\n  };\n};\n\nconst tagFilter = (tags: NonBlend) => {\n  const filterSet = tags.outRanges.flatMap((val, j) => {\n    const tagMeta = tags.metaData[j];\n    let tagVal: Array<number[]>;\n    if (val.every((i, j) => i === val[0] + j)) {\n      tagVal = [val];\n    } else if (val.includes(-1)) {\n      const tagValOne = splitOneGap(val);\n      tagVal = tagValOne.flatMap((range) => splitGap(range));\n    } else {\n      tagVal = splitGap(val);\n    }\n\n    return tagVal.map((tag) => ({\n      ...tagMeta,\n      start: Math.min(...tag),\n      end: Math.max(...tag),\n    }));\n  });\n  return filterSet.filter((tag) => isFinite(tag.start) || isFinite(tag.end));\n};\n\nexport const blender = (tags: Array<Tag>) => {\n  const currentTags = sortBy(tags, [\"start\"]);\n\n  const overlap = getOverlap(currentTags);\n\n  if (overlap.length) {\n    const { outRanges, metaData, tagIndices } = updateIndices(\n      currentTags,\n      overlap\n    );\n\n    const outTags = tagFilter({ outRanges, metaData });\n\n    const remainder = currentTags.filter(\n      (_, index) => !tagIndices.includes(index)\n    );\n\n    return {\n      tags: [...overlap, ...outTags, ...remainder],\n      blendIndices: tagIndices,\n    };\n  } else return { tags: currentTags, blendIndices: [] };\n};\n","import React from \"react\";\nimport { luminTest } from \"./utils/utils\";\n\nexport interface MarkProps {\n  key: string;\n  content: string;\n  start: number;\n  end: number;\n  tag: string;\n  color?: string;\n  onClick: (arg0: any) => any;\n}\n\n//TODO, props setting for tag value\n//remove rad on blend\n\nconst Mark: React.FC<MarkProps> = (props) => {\n  const lumin = props.color ? luminTest(props.color) : false;\n\n  return (\n    <mark\n      style={{\n        backgroundColor: props.color || \"#84d2ff\",\n        padding: \"0 4px\",\n        ...(lumin && { color: \"white\" }),\n        // borderRadius: props.tag ? \"3px\" : \"0px\",\n      }}\n      data-start={props.start}\n      data-end={props.end}\n      onMouseUp={() => props.onClick({ start: props.start, end: props.end })}\n    >\n      {props.content}\n      {props.tag && (\n        <span style={{ fontSize: \"0.7em\", fontWeight: 500, marginLeft: 6 }}>\n          {props.tag}\n        </span>\n      )}\n    </mark>\n  );\n};\n\nexport default Mark;\n","import React from \"react\";\nimport Mark from \"./Mark\";\n\nexport interface SplitProps {\n  key: string;\n  content: string;\n  start: number;\n  end: number;\n  tag?: string;\n  color?: string;\n  onClick: (arg0: any) => any;\n}\n\nconst SplitTag:React.FC<SplitProps> = (props: any) => {\n\n    if (props.mark) return <Mark {...props} />;\n  \n    return (\n      <span\n        data-start={props.start}\n        data-end={props.end}\n        onClick={() => props.onClick({ start: props.start, end: props.end })}\n      >\n        {props.content}\n      </span>\n    );\n  };\n\n  export default SplitTag;","import React from \"react\";\nimport { blender } from \"./utils/blend\";\nimport SplitTag from \"./SplitTag\";\nimport sortBy from \"lodash.sortby\";\nimport {\n  selectionIsEmpty,\n  selectionIsBackwards,\n  splitWithOffsets,\n  tagTransformer,\n} from \"./utils/utils\";\n\n\ninterface Split {\n  start: any;\n  end: any;\n}\n\ninterface TextSpan extends Span {\n  text: string;\n}\n\ntype Span = {\n  start: number;\n  end: number;\n};\n\n\ntype TextBaseProps<T> = {\n  content: string;\n  value: T[];\n  onChange: (value: T[]) => any;\n  getSpan?: (span: TextSpan) => T;\n};\n\ntype TextAnnotateBlendProps<T> = React.HTMLAttributes<HTMLDivElement> &\n  TextBaseProps<T>;\n\nconst TextAnnotateBlend = <T extends Span>(props: TextAnnotateBlendProps<T>) => {\n  const getSpan = (span: TextSpan): T => {\n    if (props.getSpan) return props.getSpan(span) as T;\n    return { start: span.start, end: span.end } as T;\n  };\n\n  const handleMouseUp = () => {\n    if (!props.onChange) return;\n\n    const selection = window.getSelection();\n    if (selection && selection.anchorNode && selection?.focusNode) {\n      if (selectionIsEmpty(selection)) return;\n\n      let startBase = selection.anchorNode.parentElement?.getAttribute(\n        \"data-start\"\n      );\n      let endBase = selection.focusNode.parentElement?.getAttribute(\n        \"data-start\"\n      );\n      if (startBase == null || endBase == null) return;\n\n      let start = parseInt(String(startBase), 10) + selection.anchorOffset;\n      let end = parseInt(String(endBase), 10) + selection.focusOffset;\n\n      if (selectionIsBackwards(selection)) {\n        [start, end] = [end, start];\n      }\n      tagTransformer(\n        [\n          ...props.value,\n          getSpan({ start, end, text: content.slice(start, end) }),\n        ],\n        props.onChange\n      );\n\n      window.getSelection()?.empty();\n    }\n  };\n\n  const handleSplitClick = ({ start, end }: Split) => {\n    const selection = window.getSelection();\n\n    let focusOffset = 0;\n    let anchorOffset = 0;\n    if (selection) {\n      focusOffset = selection.focusOffset;\n      anchorOffset = selection.anchorOffset;\n    }\n    if (focusOffset - anchorOffset !== 0) {\n      return;\n    }\n\n    const { blendIndices } = blender(value);\n\n    const currentTags = sortBy(props.value, [\"start\"]);\n    const frontOverlapIndex = currentTags.findIndex(\n      (tag, index) => tag.start === start && blendIndices.includes(index)\n    );\n\n    const rearOverlapIndex = currentTags.findIndex(\n      (tag, index) => tag.end === end && blendIndices.includes(index)\n    );\n\n    const splitIndex = props.value.findIndex(\n      (s) => s.start === start && s.end === end\n    );\n\n    if (splitIndex >= 0) {\n      tagTransformer(\n        [\n          ...props.value.slice(0, splitIndex),\n          ...props.value.slice(splitIndex + 1),\n        ],\n        props.onChange\n      );\n    } else if (frontOverlapIndex >= 0) {\n      tagTransformer(\n        [\n          ...props.value.slice(0, frontOverlapIndex),\n          ...props.value.slice(frontOverlapIndex + 1),\n        ],\n        props.onChange\n      );\n    } else if (rearOverlapIndex >= 0) {\n      tagTransformer(\n        [\n          ...props.value.slice(0, rearOverlapIndex),\n          ...props.value.slice(rearOverlapIndex + 1),\n        ],\n        props.onChange\n      );\n    }\n  };\n\n  const { content, value, style } = props;\n  const { tags } = blender(value);\n\n  let splits = splitWithOffsets(content, tags);\n\n  return (\n    <div style={style} onMouseUp={handleMouseUp}>\n      {splits.map((split) => (\n        <SplitTag\n          key={`${split.start}-${split.end}`}\n          {...split}\n          onClick={handleSplitClick}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default TextAnnotateBlend;\n","import React, { useState } from \"react\";\nimport TextAnnotateBlend from \"./components/TextAnnotateBlend\";\nimport Box from \"@material-ui/core/Box\";\nimport Paper from \"@material-ui/core/Paper\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Select from \"@material-ui/core/Select\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\nimport { docco } from \"react-syntax-highlighter/dist/esm/styles/hljs\";\n\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    flexGrow: 1,\n  },\n  menuButton: {\n    marginRight: theme.spacing(2),\n  },\n  title: {\n    flexGrow: 1,\n  },\n  main: {\n    paddingLeft: \"10%\",\n    paddingRight: \"10%\",\n  },\n\n  pre: {\n    overflowX: \"auto\",\n  },\n}));\n\nlet colA = \"rgb(179, 245, 66)\";\nlet colB = \"#42f5f5\";\nlet colC = \"#4B46CD\";\n\nconst init = [\n    {\n      \"start\": 6,\n      \"end\": 14,\n      \"text\": \"are many\",\n      \"tag\": \"tagA\",\n      \"color\": \"rgb(179, 245, 66)\"\n    },\n    {\n      \"start\": 10,\n      \"end\": 23,\n      \"text\": \"many stories \",\n      \"tag\": \"tagC\",\n      \"color\": \"#4B46CD\"\n    },\n    {\n      \"start\": 78,\n      \"end\": 82,\n      \"text\": \"road\",\n      \"tag\": \"tagB\",\n      \"color\": \"#42f5f5\"\n    }\n  ];\n//node_modules/react\nexport default function Demo() {\n  const classes = useStyles();\n  const [value, setValue] = useState(init);\n  const [tag, setTag] = useState(\"tagA\");\n\n  const handleChange = (value: any) => {\n    setValue(value);\n  };\n\n  interface Colors {\n    [key: string]: string;\n    tagA: string;\n    tagB: string;\n  }\n\n  const COLORS: Colors = {\n    tagA: colA,\n    tagB: colB,\n    tagC: colC,\n  };\n\n  return (\n    <Paper className={classes.main}>\n      <Box p={2}>\n        <h3>TextAnnotateBlend</h3>\n      </Box>\n      <Box pl={2} mb={2}>\n        <strong>Simply highlight to tag & Click to untag</strong>\n      </Box>\n      \n      <Paper elevation={2}>\n      <Box p={2}>\n        <TextAnnotateBlend\n          style={{\n            maxWidth: 500,\n            fontSize: \"1.2rem\",\n            // lineHeight: 5,\n          }}\n          content=\"There are many stories about the origins of cyclo-cross. One is that European road racers in the early 1900s would race each other to the next town over from them and that they were allowed to cut through farmers' fields or over fences, or take any other shortcuts, in order to make it to the next town first. This was sometimes called steeple chase as the only visible landmark in the next town was often the steeple.\"\n          onChange={handleChange}\n          value={value}\n          getSpan={(span: any) => ({\n            ...span,\n            tag: tag,\n            color: COLORS[tag],\n          })}\n        />\n        \n      </Box>\n      </Paper>\n\n      <Box p={2}>\n        <FormControl variant=\"outlined\">\n          <Select\n            //   labelId=\"demo-simple-select-disabled-label\"\n            id=\"demo-simple-select-disabled\"\n            value={tag}\n            onChange={(e) => setTag(e.target.value as string)}\n          >\n            <MenuItem value=\"tagA\">tagA</MenuItem>\n            <MenuItem value=\"tagB\">tagB</MenuItem>\n            <MenuItem value=\"tagC\">tagC</MenuItem>\n          </Select>\n        </FormControl>\n      </Box>\n      <Box pt={2}>\n        <h3>Current Stored Value</h3>\n      </Box>\n      <Paper elevation={2} className={classes.pre}>\n        <pre>{JSON.stringify(value, null, 2)}</pre>\n      </Paper>\n      <Box pt={3}>\n        <h3>Sample Code</h3>\n      </Box>\n      <Box pb={3}>\n      <SyntaxHighlighter language=\"javascript\" style={docco}>\n        {`\nimport { TextAnnotateBlend } from \"react-text-annotate-blend\";\n\nApp = () => {\n    const [value, setValue] = useState(init);\n    const [tag, setTag] = useState(\"tagA\");\n\n    const handleChange = (value) => {\n        setValue(value);\n    };\n\n    const COLORS = {\n        tagA: \"rgb(179, 245, 66)\",\n        tagB: \"#42f5f5\",\n    };\n\n    return (\n        <>\n        <TextAnnotateBlend\n            style={{\n            maxWidth: 500,\n            fontSize: \"1.2rem\",\n            }}\n            content=\"This component lets you blend annotations!\"\n            onChange={handleChange}\n            value={value}\n            getSpan={(span) => ({\n                ...span,\n                tag: tag,\n                color: COLORS[tag],\n            })}\n        />\n        <select value={tag} onChange={(e) => setTag(e.target.value)}>\n            <option value=\"tagA\">tagA</option>\n            <option value=\"tagB\">tagB</option>\n        </select>\n\n        <pre>{JSON.stringify(value, null, 2)}</pre>\n    </>\n);\n    }`}\n      </SyntaxHighlighter>\n      </Box>\n      <Box pt={3}>\n        <h3>Props (Coming Soon)</h3>\n      </Box>\n    </Paper>\n  );\n}\n","import React, { useState } from \"react\";\nimport TextAnnotateBlend from \"./components/TextAnnotateBlend\"\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport Typography from '@material-ui/core/Typography';\nimport Container from '@material-ui/core/Container';\nimport { makeStyles } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Button from '@material-ui/core/Button';\nimport Box from '@material-ui/core/Box';\nimport IconButton from '@material-ui/core/IconButton';\nimport Demo from './Demo'\n// import MenuIcon from '@material-ui/icons/Menu';\n\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    flexGrow: 1,\n  },\n  menuButton: {\n    marginRight: theme.spacing(2),\n  },\n  title: {\n    flexGrow: 1,\n  },\n}));\n\nexport default function App() {\n  const classes = useStyles();\n  return (\n  <React.Fragment>\n    <CssBaseline />\n    <div className={classes.root}>\n      <AppBar position=\"static\">\n        <Toolbar>\n          <IconButton edge=\"start\" className={classes.menuButton} color=\"inherit\" aria-label=\"menu\">\n          </IconButton>\n          <Typography variant=\"h6\" className={classes.title}>\n            react-text-annotate-blend\n          </Typography>\n          <Button color=\"inherit\" href={'https://github.com/smhaley/react-text-annotate-blend'}>source</Button>\n        </Toolbar>\n      </AppBar>\n    </div>\n    <Container maxWidth=\"md\" style={{height: '100%' }}>\n       <Box m={3}>\n       <Demo/>\n       </Box>\n\n      </Container>\n  </React.Fragment>\n  );\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { createMuiTheme, ThemeProvider }  from '@material-ui/core';\n\n\nconst theme = createMuiTheme({\n  props: {\n    // Name of the component ⚛️\n    MuiButtonBase: {\n      // The properties to apply\n      disableRipple: true, // No more ripple, on the whole application 💣!\n    },\n  },\n});\n\nReactDOM.render(\n  <React.StrictMode>\n      <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}